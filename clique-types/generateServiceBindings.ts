import * as fs from 'fs';
import * as glob from 'glob';
import { each, head, map } from 'lodash';
import * as path from 'path';
import * as shell from 'shelljs';

const SRC_DIR_NAME = 'src';
const SCHEMA_DIR_NAME = 'Schemas';
const BINDING_DIR_NAME = 'ServiceBindings';

const GENERATED_JS_FILE_HEADER = `
/******************************************************************************
*
* DO NOT EDIT THIS FILE.
*
* The contents of this file were generated by generateServiceBindings.ts
*
******************************************************************************/
`;

function generateImportExportJsFile(name) {
  const fileContents = `${GENERATED_JS_FILE_HEADER}
  import { ${name} } from '../Schemas'
  import ServiceBinding, { buildRootSchema } from './Binding';

  interface ICreateBinding {
    uri: string,
    headersToForward: string[]
  }

  export default function ${name}Binding({ uri, headersToForward }: ICreateBinding) {
    return new ServiceBinding({
      typeDefs: buildRootSchema(${name}),
      uri,
      headersToForward,
    });
  }
`;
  return fileContents;
}

function generateTypeDefinitionsIndex(files) {
  each(files, ({ name }) => {
    return fs.writeFileSync(
      path.join(
        SRC_DIR_NAME,
        `${BINDING_DIR_NAME}/${head(name.split('Root'))}Binding.ts`
      ),
      generateImportExportJsFile(name)
    );
  });
}

function readSchemaRootTypes() {
  const directory = path.join(SRC_DIR_NAME, SCHEMA_DIR_NAME);
  // get a list of all files recursively
  const files = glob.sync(`${directory}/**/*.graphql`);
  return map(files, filePath => {
    const { name } = path.parse(filePath);

    shell.sed('-i', /.*#\s*([^\n\r]*)/, '', filePath);

    return {
      name
    };
  });
}

function main() {
  const types = readSchemaRootTypes();

  return generateTypeDefinitionsIndex(types);
}

main();
