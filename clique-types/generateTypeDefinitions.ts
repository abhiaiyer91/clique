import * as fs from 'fs';
import * as glob from 'glob';
import { last, map, reduce } from 'lodash';
import * as mkdirp from 'mkdirp';
import * as path from 'path';
import * as shell from 'shelljs';

const TYPE_DEFINITIONS_JS_FILENAME = 'typeDefinitions.ts';
const SRC_DIR_NAME = 'src';
const NON_GENERATED_GRAPHQL_TYPES_DIR_NAME = 'typeDefs';
const ENUMS_DIR_NAME = 'enums';

const GENERATED_JS_FILE_HEADER = `
/******************************************************************************
*
* DO NOT EDIT THIS FILE.
*
* The contents of this file were generated by generateTypeDefinitions.ts
*
******************************************************************************/
`;

function generateGraphqlFileContents(str) {
  return `
${str}
`;
}

function generateImportExportJsFile(importList, exportList) {
  const fileContents = `${GENERATED_JS_FILE_HEADER}
${importList}
export default {
  ${exportList}
}
`;
  return fileContents;
}

function generateTypeDefinitionsIndex(files) {
  const importList = reduce(
    files,
    (memo, { name, filePath }) => {
      const typeDef = fs.readFileSync(filePath, 'utf-8');
      if (!!memo[name]) {
        return memo;
      }
      return {
        text: (memo.text += `const ${name} = \`\n${typeDef.trim()}\n\`;\n\n`),
        [name]: true,
      };
    },
    { text: '' }
  );

  const exportList = reduce(
    files,
    (memo, { name }) => {
      return `${memo}${name},\n`;
    },
    ''
  );

  fs.writeFileSync(
    path.join(SRC_DIR_NAME, TYPE_DEFINITIONS_JS_FILENAME),
    generateImportExportJsFile(importList.text, exportList)
  );
}

function queryNameAndFileFromPath(path) {
  const queryFile = path.replace('./src/queries/', '');
  const queryName = last(queryFile.replace('.graphql', '').split('/'));
  return { queryFile: path, queryName };
}

function generateIndexFileForGraphqlQueries() {
  console.log('processing ./src/queries/**/*.graphql...\n');
  const files = glob.sync('./src/queries/**/*.graphql');

  const importList = reduce(
    files,
    (memo, currentVal) => {
      const { queryName, queryFile } = queryNameAndFileFromPath(currentVal);
      const fileContent = fs.readFileSync(queryFile, 'utf-8');
      return (memo += `const ${queryName} = \`${fileContent.trim()}\`;\n`);
    },
    ''
  );

  const exportList = reduce(
    files,
    (memo, currentVal) => {
      const { queryName: exportName } = queryNameAndFileFromPath(currentVal);
      console.log(exportName);
      return (memo += `${exportName},\n`);
    },
    ''
  );

  // write the index.ts file
  const indexFileDestination = './src/queries/index.ts';
  fs.writeFileSync(
    indexFileDestination,
    generateImportExportJsFile(importList, exportList)
  );
  console.log(
    `\nquery processing done. wrote queries index file to ${indexFileDestination}\n`
  );
}

function generateEnumJsFile(graphqlFileContent, filePath) {
  const enumMatches = graphqlFileContent.match(/enum[\s\w]+{[\s\w]+}/);

  if (!enumMatches) {
    console.error('File contains \'enum\', but does not contain enum definition\n' + filePath);
    return;
  }

  const enumSubstr = enumMatches[0];
  const [enumLine, ...valuesLines] = enumSubstr
    .replace(/[{}]/g, '')
    .split(/\n/);

  const enumName = enumLine.match(/enum\s+(\w+)\s+/)[1];

  const declarationLine = enumLine
    .trim()
    .replace(/enum\s+(\w+)\s*/, 'const $1 = {\n');

  const objectValueLines = valuesLines
    .filter((line) => {
      return !!line;
    })
    .map((line) => {
      return line.trim().replace(/\s*(\w+)\s*/, '  $1: \'$1\',');
    })
    .join('\n');

  const objectEndLine = '\n};\n';

  const exportLine = `\nexport default ${enumName};\n`;

  const fullPath = path.join(SRC_DIR_NAME, ENUMS_DIR_NAME);
  const fullPathWithFile = path.join(fullPath, `${enumName}.ts`);

  try {
    mkdirp(fullPath, (err) => {
      if (err) {
        return console.error(err);
      }
      return fs.writeFileSync(
        fullPathWithFile,
        GENERATED_JS_FILE_HEADER + '\n' + declarationLine + objectValueLines + objectEndLine + exportLine,
      );
    });
  } catch (e) {
    console.error(e);
  }
}

function readNonGeneratedGraphqlTypes() {
  const directory = path.join(
    SRC_DIR_NAME,
    NON_GENERATED_GRAPHQL_TYPES_DIR_NAME
  );
  // get a list of all files recursively
  const files = glob.sync(`${directory}/**/*.graphql`);
  return map(files, (filePath) => {
    const { name } = path.parse(filePath);

    shell.sed('-i', /.*#\s*([^\n\r]*)/, '', filePath);

    const contents = fs.readFileSync(filePath, 'utf8');

    if (/\benum\b/.test(contents)) {
      generateEnumJsFile(contents, filePath);
    }

    const withoutNewLines = contents.replace(/^\s*[\r\n]/gm, '');

    // write the .graphql file
    fs.writeFileSync(filePath, generateGraphqlFileContents(withoutNewLines));

    return {
      name,
      filePath,
    };
  });
}

function main() {
  generateIndexFileForGraphqlQueries();
  const nonGeneratedFiles = readNonGeneratedGraphqlTypes();

  generateTypeDefinitionsIndex([...nonGeneratedFiles]);
}

// MAIN SCRIPT ENTRYPOINT
main();
